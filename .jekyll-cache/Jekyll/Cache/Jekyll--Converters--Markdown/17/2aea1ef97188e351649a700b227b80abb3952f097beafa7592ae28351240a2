I"“6<p><strong>Programmers</strong> working in the game industry are proud people. And they (the good ones at least) have the right to be. It is a hard job. We care about performance, and we want our code to be fast - sometimes more than necessary. But we usually look for problems in the wrong places, we try to optimize our code by using faster algorithms but never check or care about where we put our data.</p>

<p>In recent years, the increase in CPU speed compared to the increase in memory speed is enormous. As good as it sounds, it is not actually a good thing. In the past, CPU speed and memory speed were similar and they worked in harmony. But today, because of the speed difference, CPU waits for the memory for data and wastes precious cycles doing nothing.</p>

<p>This is called a <strong>cache miss</strong>. Whenever the CPU wants some piece of data and canâ€™t find it, it is a cache miss. And it looks to a higher level cache, if it canâ€™t find it there, thatâ€™s another cache miss. It will keep looking into higher and higher level cahes and until it can find what itâ€™s looking for.</p>

<p>The computer I am writing this post on is a Mid 2011 Mac Mini and according to the CPU specs it has one <strong>32KB L1 cache</strong> and one <strong>256KB L2 cache</strong> on each core, and one <strong>3MB L3 cache</strong> on chip. The smaller the size of the cache the faster the cache is.</p>

<h3 id="cache-miss">Cache Miss</h3>
<p>The reason for a cache miss is bad data locality. Letâ€™s examine this simple code piece written in c++.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Big</span>
<span class="p">{</span>
	<span class="ss">private:
		</span><span class="n">int</span> <span class="n">actor</span><span class="p">;</span> <span class="sr">//</span> <span class="mi">32</span><span class="n">b</span> <span class="n">primitive</span> <span class="n">type</span>
		<span class="n">int</span> <span class="n">clutter</span><span class="p">[</span><span class="mi">262144</span><span class="p">];</span> <span class="sr">//</span> <span class="p">(</span><span class="mi">1</span><span class="no">KB</span> <span class="o">-</span> <span class="mi">32</span><span class="n">b</span><span class="p">)</span> <span class="no">Size</span> <span class="n">of</span> <span class="n">big</span> <span class="n">is</span> <span class="n">exactly</span> <span class="mi">1</span><span class="no">KB</span>
	<span class="ss">public:
		</span><span class="n">void</span> <span class="n">setActor</span><span class="p">(</span><span class="n">int</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">int</span> <span class="n">getActor</span><span class="p">();</span>
		<span class="n">float</span> <span class="n">getSizeInKB</span><span class="p">();</span>
		<span class="n">float</span> <span class="n">getSizeInMB</span><span class="p">();</span>
		<span class="n">void</span> <span class="n">fillClutter</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure>

<h6 id="a-class-when-instanced-creates-an-object-which-is-1kb-in-size">A class when instanced creates an object which is 1KB in size</h6>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Small</span>
<span class="p">{</span>
	<span class="ss">private:
		</span><span class="n">int</span> <span class="n">actor</span><span class="p">;</span>
	<span class="ss">public:
		</span><span class="n">void</span> <span class="n">setActor</span><span class="p">(</span><span class="n">int</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">int</span> <span class="n">getActor</span><span class="p">();</span>
		<span class="n">float</span> <span class="n">getSizeInKB</span><span class="p">();</span>
		<span class="n">float</span> <span class="n">getSizeInMB</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure>

<h6 id="a-class-when-instanced-creates-an-object-which-is-32b-in-size">A class when instanced creates an object which is 32b in size</h6>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">void</span> <span class="kp">loop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">const</span> <span class="n">int</span> <span class="no">SIZE</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span>

	<span class="no">Big</span><span class="o">*</span> <span class="n">bigs</span> <span class="o">=</span> <span class="n">new</span> <span class="no">Big</span><span class="p">[</span><span class="no">SIZE</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">bigs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">setActor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="no">Small</span><span class="o">*</span> <span class="n">smalls</span> <span class="o">=</span> <span class="n">new</span> <span class="no">Small</span><span class="p">[</span><span class="no">SIZE</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">smalls</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">setActor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h6 id="here-we-loop-through-the-arrays">Here, we loop through the arrays</h6>

<p>On average the second loop completes ~7 times faster than the first loop on my machine. The process is the same, which is setting an int field of an object. Why is that? Because the <strong>clutter</strong> in the Big object causes the CPU to miss the cached data, because the L1 and L2 caches are full of unnecessary data.</p>

<p>Letâ€™s examine how our data is placed on the actual memory using <strong>lldb</strong>. You can also use <strong>gdb</strong>, they are very similar.</p>

<p>Compile the script above using clang++ with -g flag to enable debugging with extra information. Here is the simple compile command.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">clang</span><span class="o">++</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">o</span> <span class="nb">p</span> <span class="n">main</span><span class="p">.</span><span class="nf">cpp</span></code></pre></figure>

<p>Load the program to lldb using</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">lldb</span> <span class="nb">p</span></code></pre></figure>

<p>and then add a simple breakpoint to pause the process without terminating it.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">b</span> <span class="n">main</span><span class="p">.</span><span class="nf">cpp</span><span class="p">:</span> <span class="mi">125</span></code></pre></figure>

<p>Run the program.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">run</span></code></pre></figure>

<p>At some point lldb will show the addresses of our two arrays because it is the output of our program, using those addresses we can examine the memory and see what they have - it may show different addresses on your computer.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Address</span> <span class="n">of</span> <span class="ss">smalls: </span><span class="mh">0x1000c4000</span>
<span class="no">Address</span> <span class="n">of</span> <span class="ss">bigs: </span><span class="mh">0x101000000</span></code></pre></figure>

<p>Lets examine the first 32 elements of the <em>smalls</em> array using</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">memory</span> <span class="n">read</span> <span class="o">-</span><span class="n">fx</span> <span class="mh">0x1000c4000</span> <span class="mh">0x1000c4000</span><span class="o">+</span><span class="mi">128</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mh">0x1000c4000</span><span class="p">:</span> <span class="mh">0x00000000</span> <span class="mh">0x00000001</span> <span class="mh">0x00000002</span> <span class="mh">0x00000003</span>
<span class="mh">0x1000c4010</span><span class="p">:</span> <span class="mh">0x00000004</span> <span class="mh">0x00000005</span> <span class="mh">0x00000006</span> <span class="mh">0x00000007</span>
<span class="mh">0x1000c4020</span><span class="p">:</span> <span class="mh">0x00000008</span> <span class="mh">0x00000009</span> <span class="mh">0x0000000a</span> <span class="mh">0x0000000b</span>
<span class="mh">0x1000c4030</span><span class="p">:</span> <span class="mh">0x0000000c</span> <span class="mh">0x0000000d</span> <span class="mh">0x0000000e</span> <span class="mh">0x0000000f</span>
<span class="mh">0x1000c4040</span><span class="p">:</span> <span class="mh">0x00000010</span> <span class="mh">0x00000011</span> <span class="mh">0x00000012</span> <span class="mh">0x00000013</span>
<span class="mh">0x1000c4050</span><span class="p">:</span> <span class="mh">0x00000014</span> <span class="mh">0x00000015</span> <span class="mh">0x00000016</span> <span class="mh">0x00000017</span>
<span class="mh">0x1000c4060</span><span class="p">:</span> <span class="mh">0x00000018</span> <span class="mh">0x00000019</span> <span class="mh">0x0000001a</span> <span class="mh">0x0000001b</span>
<span class="mh">0x1000c4070</span><span class="p">:</span> <span class="mh">0x0000001c</span> <span class="mh">0x0000001d</span> <span class="mh">0x0000001e</span> <span class="mh">0x0000001f</span>
<span class="o">...</span>		</code></pre></figure>

<p>Look at how nicely the elements are stored on the memory. The first element is 0, the second is 1, the third is 2 and so on, as expected.</p>

<p>Now letâ€™s examine the first 32 elements of the <em>bigs</em> array using</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">memory</span> <span class="n">read</span> <span class="o">-</span><span class="n">fx</span> <span class="mh">0x101000000</span> <span class="mh">0x101000000</span><span class="o">+</span><span class="mi">128</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mh">0x100200000</span><span class="p">:</span> <span class="mh">0x00000000</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200010</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200020</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200030</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200040</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200050</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200060</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="mh">0x100200070</span><span class="p">:</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span> <span class="mh">0xffffffff</span>
<span class="o">...</span></code></pre></figure>

<p>See, itâ€™s full of unnecessary data that causes the CPU to miss the cache.</p>

<h3 id="conclusion">Conclusion</h3>

<p>It has been a very long time since the hype of Data Oriented Programming, and I have been programming in a data oriented way for almost a year now. At first (like most of the things I first encounter) I thought it was the holy grail and will solve each and every problem, but now I think there is a place for OOD and DOD (and in that sense other programming paradigms) in the same software. Both of them have their strengths and weaknesses. Till memory speed catches up with CPU speed, using DOD is a very good idea.</p>

<p>You can find the source files in this <a href="/assets/2017/dod_tests-master.zip">file</a>.</p>

<p>If you think that this blog post is wrong or missing, please send me a message.</p>
:ET